+class Matrix()
	+var data: [][]float
	var maxlen: int
	+func new(mem: [][]float)
		var len: int :: ^mem[0]
		do me.maxlen :: 1
		for i(0, ^mem - 1)
			if(^mem[i] <> len)
				do dbg@print("行列になっていません。")
				throw 0x00000001
			end if
		end for
		do me.data :: mem
	end func
	;単位行列
	+func newId(I: int)
		do me.data :: #[I, I]float
		for i(0, I - 1)
			for j(0, I - 1)
				if(i = j)
					do me.data[i][j] :: 1.0
				end if
			end for
		end for
	end func
	+func trans(): @Matrix
		var transM: [][]float :: #[^me.data[0], ^me.data]float
		for i(0, ^transM - 1)
			for j(0, ^transM[0] - 1)
				do transM[i][j] :: me.data[j][i]
			end for
		end for
		var transverse: @Matrix :: #@Matrix
		do transverse.new(transM)
		ret transverse
	end func
	+func shape(): []int
		ret[^me.data, ^me.data[0]]
	end func
	+*func toStr(): []char
		var c: []char :: "|"
		for i(0, ^me.data - 1)
			for j(0, ^me.data[0] - 1)
				do me.maxlen :: (^me.data[i][j].toStr()) > me.maxlen ?(^me.data[i][j].toStr(), me.maxlen)
			end for
		end for
		for i(0, ^me.data - 1)
			for j(0, ^me.data[0] - 1)
				for(0, me.maxlen - ^me.data[i][j].toStr())
					do c :~ " "
				end for
				do c :~ me.data[i][j].toStr() ~ (j = ^me.data[0] - 1 ?("|\n", ","))
			end for
			if(i <> ^me.data - 1)
				do c :~ "|"
			end if
		end for
		ret c
	end func
	;LU分解
	+func LUDec(): []@Matrix
		do @checksq(&me, null)
		var temp: @Matrix :: ##me
		var L: @Matrix :: #@Matrix
		do L.new(#[^me.data, ^me.data]float)
		var U: @Matrix :: #@Matrix
		do U.newId(^me.data)
		var lu: @Matrix :: ##L
		for i(0, ^me.data - 1)
			var n: int :: ^me.data - i - 1
			do L.data[i][i] :: temp.data[0][0]
			var l0: float :: L.data[i][i]
			
			var u1: []float :: #[n]float
			for j(0, n - 1)
				do L.data[i + j + 1][i] :: temp.data[j + 1][0]
				try
					do U.data[i][j + i + 1] :: temp.data[0][j + 1] / l0
				catch 0xC0000090
					do dbg@print("LU分解できない行列です。")
					throw 0x00000005
				end try
				do u1[j] :: U.data[i][j + i + 1]
			end for
			
			
			for j(0, n - 1)
				for k(0, n - 1)
					do lu.data[j][k] :: temp.data[j + 1][0] * u1[k]
				end for
			end for
			if(n = 0)
				break i
			end if
			var A1: @Matrix :: #@Matrix
			do A1.new(#[n, n]float)
			for j(0, n - 1)
				for k(0, n - 1)
					do A1.data[j][k] :: temp.data[j + 1][k + 1] - lu.data[j][k]
				end for
			end for
			
			do temp :: A1
		end for
		var retMat: []@Matrix :: #[2]@Matrix
		do retMat[0] :: L
		do retMat[1] :: U
		ret retMat
	end func
	;列、行ベクトルを一次元配列に変換する
	+func VecToArray(): []float
		do @checkVec(&me, null)
		if(^me.data = 1)
			ret me.data[0]
		end if
		if(^me.data[0] = 1)
			ret me.trans().data[0]
		end if
	end func
end class

func checkVec(mat: &@Matrix, err: []char)
	if(^mat.data > 1 & ^mat.data[0] > 1)
		var text: []char :: (err =& null ?("", err)) ~ "列または行ベクトルではありません。"
		do dbg@print(text)
		throw 0x00000004
	end if
end func
func checksq(mat: &@Matrix, err: []char)
	if(^mat.data <> ^mat.data[0])
		var text: []char :: (err =& null ?("", err)) ~ "正方行列ではありません。"
		do dbg@print(text)
		throw 0x00000003
	end if
end func
func checkShape(m1: &@Matrix, m2: &@Matrix)
	if(m1.shape()[0] <> m2.shape()[0] | m1.shape()[1] <> m2.shape()[1])
		do dbg@print("行または列の数が一致しません。")
		throw 0x00000002
	end if
end func

+func add(m1: &@Matrix, m2: &@Matrix): @Matrix
	do @checkShape(&m1, &m2)
	var temp: @Matrix :: ##m1
	for i(0, ^m1.data - 1)
		for j(0, ^m1.data[0] - 1)
			do temp.data[i][j] :+ m2.data[i][j]
		end for
	end for
	ret temp
end func

+func minus(m1: &@Matrix, m2: &@Matrix): @Matrix
	do @checkShape(&m1, &m2)
	var temp: @Matrix :: ##m1
	for i(0, ^m1.data - 1)
		for j(0, ^m1.data[0] - 1)
			do temp.data[i][j] :- m2.data[i][j]
		end for
	end for
	ret temp
end func

+func mul(m1: &@Matrix, m2: &@Matrix): @Matrix
	if(^m1.data[0] <> ^m2.data)
		do dbg@print("列と行が一致していません")
		throw 0x00000003
	end if
	var temp: @Matrix :: m2.trans()
	var mulMat: @Matrix :: #@Matrix
	do mulMat.new(#[^m1.data, ^m2.data[0]]float)
	for i(0, ^m1.data - 1)
		for j(0, ^mulMat.data[0] - 1)
			var t: float :: 0.0
			for k(0, ^m1.data[0] - 1)
				do t :+ (m1.data[i][k] * temp.data[j][k])
			end for
			do mulMat.data[i][j] :: t
		end for
	end for
	ret mulMat
end func

+func solvEq(coefficient: &@Matrix, rvalue: &@Matrix): @Matrix
	do @checksq(&coefficient, "係数行列が")
	do @checkVec(&rvalue, "右辺値が")
	var L: @Matrix :: coefficient.LUDec()[0]
	var U: @Matrix :: coefficient.LUDec()[1]
	var y: []float :: #[^coefficient.data]float
	for i(0, ^coefficient.data - 1)
		var sum: float :: 0.0
		for k(0, i - 1, 1)
			do sum :+ L.data[i][k] * y[k]
		end for
		do y[i] :: (rvalue.VecToArray()[i] - sum) / L.data[i][i]
	end for
	
	var x: @Matrix :: #@Matrix
	do x.new(#[^coefficient.data, 1]float)
	for i(^coefficient.data - 1, 0, -1)
		var sum: float :: 0.0
		for k(i + 1, ^coefficient.data - 1, 1)
			do sum :+ U.data[i][k] * x.data[k][0]
		end for
		do x.data[i][0] :: y[i] - sum
	end for
	ret x
end func
